\chapter{Функции обработчика прерывания системного таймера}



\section{Unix/Linux}

\textbf{По тику}
\begin{itemize}
	\item Инкремент счётчика реального времени;
	\item Декремент кванта;
	\item Инкремент счётчиков процессорного времени в режимах задачи и ядра(utime и stime в struct task\_struct) ;
	\item Декремент счётчика тиков отложенных вызовов. Если счётчик обнулился, то установка флага запуска ожидающего вызова.
\end{itemize}

\textbf{По главному тику}
\begin{itemize}
    \item Пробуждение системных процессов (например \texttt{pagedaemon}, \texttt{swapper} для Unix, \texttt{kswapd} для Linux);
    \item Отложенный вызов функций планировщика (пересчёт приоритетов);
    \item Декремент счетчика времени, которое осталось до посылки одного из следующих сигналов:
    \begin{itemize}
        \item \texttt{SIGVTALRM} -- сигнал, посылаемый процессу по истечении времени работы в режиме задачи;
        \item \texttt{SIGPROF} -- сигнал, посылаемый процессу по истечении времени, заданного в таймере профилирования;
        \item \texttt{SIGALRM} -- сигнал, посылаемый процессу по истечении времени, будильником реального времени.
    \end{itemize}
\end{itemize}

\textbf{По кванту}
\begin{itemize}
	\item Отправка сигнала SIGXCPU  текущему процессу, если он превысил выделенный ему квант процессорного времени.
\end{itemize}

\section{Windows}

\textbf{По тику}
\begin{itemize}
	\item Инкремент счётчика реального времени;
	\item Декремент кванта;
	\item Декремент счётчика тиков отложенных вызовов;
	\item Запись адреса выполняемого кода при активном профилировании ядра.
\end{itemize}

\textbf{По главному тику}
\begin{itemize}
	\item  Инициализация диспетчера настройки баланса путем сбрасывания объекта «событие», на котором он ожидает;
\end{itemize}

\textbf{По кванту}
\begin{itemize}
	\item Инициация диспетчеризации потоков - добавление соответствующего DPC~объекта в очередь DPC.
\end{itemize}

\chapter{Пересчёт динамических приоритетов}

Операционные системы Unix и Windows являются системами разделения времени с динамическим приоритетами, соответственно процессорное время выделяется процессам в соответствии с их приоритетом, при этом их приоритеты меняются по ходу выполнения программы.


\section{Unix/Linux}

Планировщик Unix предоставляет каждому процессу \textbf{квант времени} - временной интервал, в течение которого процесс может использовать процессор до вытеснения другим процессом. По истечении кванта планировщик переключается на следующий процесс. При переключении процессов планировщик заставляет процессор выполнить \textbf{переключение контекста}. При этом действии ядро системы сохраняет аппаратный контекст, в том числе текущие значения регистров общего назначения. После сохранения, ядро системы загружает аппаратный контекст процесса, который будет выполняться.

В системах Unix планировщик выбирает процесс, обладающий наиболее высоким приоритетом, среди всех. При этом если процессы обладают одинаковым приоритетом, то применяется вытесняющее квантование времени для этих процессов. При этом изменение приоритетов происходит динамически и если какой-то из высокоприоритетных процессов станет готов к выполнению, то он вытеснит текущий процесс, даже если тот не израсходовал свой квант времени.

Традиционное ядро Unix является строго невытесняющим, то есть процесс, находящийся в режиме ядра, не может быть вытеснен другим, даже более высокоприоритетным процессом. Выполняющийся процесс может добровольно освободить процессор, в случае блокирования на ресурсе, или вытеснен при переходе в режим задачи. Такой подход решает проблемы синхронизации, связанные с одновременным доступом нескольких процессов к одним и тем же объектам ядра. Современные системы Unix/Linux являются вытесняющими, то есть процесс в режиме ядра может быть вытеснен более высокоприоритетным процессом.

Приоритет процесса может представляться любым целым числом в диапазоне от 0 до 127. Для системы 4.3BSD UNIX чем ниже это число, тем более высокий приоритет имеет процесс. Значения от 0 до 49 зарезервированы для режима ядра, остальные 50-127 отведены под прикладные процессы.

Структура $proc$, описывающая дескриптор процесса, содержит следующие поля, характеризующие приоритет процесса:
\begin{itemize}
	\item $p\_pri$ -- Текущий приоритет планирования;
	\item $p\_usrpri$ -- Приоритет процесса в режиме задачи;
	\item $p\_cpu$ -- Результат последнего измерения использования процессора;
	\item $p\_nice$ -- Фактор <<Любезности>> процесса, устанавливаемый пользователем.
\end{itemize}

Поле $p\_pri$ используется планировщиком для принятия решения о том, какой процесс направить на выполнение. Значение $p\_pri$ совпадает с $p\_usrpri$, когда процесс находится в режиме задачи. Когда процесс просыпается после блокирования в системном вызове, его значение $p\_pri$ понижается, то есть приоритет повышается, для того, чтобы дать ему предпочтение среди остальных процессов.

Ядро системы связывает приоритет сна с событием или ожидаемым ресурсом. Когда блокированный процесс просыпается, ядро устанавливает его значение $p\_pri$ равным приоритету сна или ресурса, при этом все эти приоритеты лежат в диапазоне 0-49, что повышает приоритет процесса по сравнению с процессами в режиме задачи. На рисунке~\ref{fig:sleep} приведены значения приоритетов сна для систем 4.3BSD UNIX и SCO UNIX (OpenServer 5.0).

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{sleep}
	\caption{Системные приоритеты сна}
	\label{fig:sleep}
\end{figure}

После завершения системного вызова перед возвращением в режим задачи ядро восстанавливает приоритет режима задачи, сохранённый перед выполнением системного вызова. Это может привести к понижению приоритета, что, в свою очередь, вызовет переключение контекста.

В режиме задачи приоритет зависит от двух факторов: <<любезности>> и последней измеренной величины использования процессора.

Степень <<любезности>> процесса определяется числом от 0 до 39 со значением 20 по умолчанию. Увеличение этого числа приводит к уменьшению приоритета процесса, таким образом такой процесс будет уступать места более высокоприоритетным процессам. Уменьшить эту величину может только суперпользователь, так как это приведёт к увеличению приоритета процесса.

Поле $p_cpu$ содержит последний результат измерения использования процессора. Эта величина увеличивается на 1 на каждом тике, при выполнении процесса, вплоть до максимального значения в 127. Также каждую секунду ядро выпускает процедуру $schedcpu()$ которая уменьшает значение $p_cpu$ по фактору <<полураспада>>. В 4.3BSD Unix для этого используется формула~\ref{eq:factor}
\begin{equation}
	\label{eq:factor}
	p\_cpu = p\_cpu\frac{2*load\_average}{2*load\_average+1},
\end{equation}
где $load\_average$ -- среднее количество готовых к выполнению процессов за последнюю секунду. После расчёта $p\_cpu$ рассчитывается приоритет процесса в режиме задачи~\ref{eq:prior-unix}.
\begin{equation}
	\label{eq:prior-unix}
	p\_usrpri = PUSER + \frac{p\_cpu}{4} + 2*p\_nice,
\end{equation}
где $PUSER = 50$ -- базовый приоритет процессов в пользовательском режиме.

В результате долгое использование процессора повышает $p\_cpu$, что понижает приоритет процесса, с другой стороны долгое нахождение в очереди процессов повышает его приоритет за счёт фактора <<полураспада>>. Такая схема предотвращает бесконечное откладывание.

В современных Unix-системах, в отличие от классической модели планирования на уровне процессов, единицей диспетчеризации является поток. Это обусловлено широким распространением многопоточного программирования, стандартизированного интерфейсом POSIX Threads (pthreads).

Каждый поток внутри процесса имеет собственные атрибуты планирования, включая приоритет и политику, что позволяет потокам одного процесса независимо конкурировать за процессорное время. Существует две основные модели реализации потоков:
\begin{itemize}
    \item Пользовательские потоки (M:1): Планирование осуществляется библиотекой в пользовательском пространстве (например, NPTL в glibc). Ядро ``видит'' лишь один соответствующий поток ядра (LWP - Lightweight Process). Пересчет приоритетов в этой модели -- задача библиотеки, использующей собственные алгоритмы, часто на основе приоритетов, заданных программистом через pthread\_attr\_setschedparam.
    \item Потоки ядра (1:1): Каждому пользовательскому потоку соответствует отдельный поток ядра (LWP). Эта модель является стандартом в современных Linux, FreeBSD, Solaris. Планировщик ядра работает с каждым таким потоком напрямую, назначая и пересчитывая приоритеты индивидуально.
\end{itemize}

Стандарт POSIX определяет для потоков несколько политик планирования, которые задаются через атрибуты потока (pthread\_attr\_t):
\begin{itemize}
    \item SCHED\_OTHER (стандартное циклическое планирование с разделением времени): Используется для обычных потоков. В рамках этой политики и происходит динамический пересчет приоритетов (например, на основе значения nice). Это политика по умолчанию.
    \item SCHED\_FIFO (планирование ``первым пришел -- первым обслужен''): Потоки с реальным временем. Приоритет статичен, назначенный поток выполняется, пока не завершится, не вытеснится потоком с более высоким приоритетом или не вызовет блокирующий системный вызов.
    \item SCHED\_RR (циклическое планирование для реального времени): Аналогично SCHED\_FIFO, но потоку выделяется квант времени, после чего он помещается в конец очереди для своего уровня приоритета.
\end{itemize}

Параметры планирования определяются структурой sched\_param, содержащей как минимум поле sched\_priority -- статический приоритет потока. Для политик реального времени (SCHED\_FIFO, SCHED\_RR) это значение является фиксированным и определяющим. Для SCHED\_OTHER это поле часто используется как базовый приоритет, относительно которого работает динамический пересчет, управляемый планировщиком ядра.

\section{Windows}

Планировщик Windows реализует приоритетную, вытесняющую систему планирования. Единицей диспетчеризации, как и в случае unix, является поток, которому при его создании задаётся базовый приоритет. Приоритеты потоков задаются относительно приоритета процесса. 

Как и в случае планировщика Unix, планировщик Windows предоставляет потоку квант времени, при этом для выполнения всегда выбирается готовый к запуску поток с наивысшим приоритетом.
Поток может перестать выполняться, если:

\begin{itemize}
	\item появился более высокоприоритетный поток (например вышел из ожидания). Тогда текущий поток будет вытеснен более высокоприоритетным потоком;
	\item поток добровольно отказался от кванта, путём входа в ожидание какого-нибудь объекта (события, мьютекса, семафора, т.д.);
	\item квант, выделенный потоку закончился. Тогда квант может быть передан более высокоприоритетным потокам, если они есть, потокам с тем же приоритетам по очереди, если они есть, либо тому же самому потоку, если есть только потоки с более низким приоритетом.
\end{itemize}

Приоритет в Windows задаётся одним из 32 значений в диапазоне от 0 до 31, при этом 0 зарезервирован для потока обнуления страниц, 1-15 -- изменяющиеся уровни, а 16-31 -- уровни реального времени. 

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{levels}
	\caption{Уровни приоритета потоков}
	\label{fig:levels}
\end{figure}

Приоритет процесса присваивается Windows API при создании процесса и может быть одним из 6 значений:
\begin{itemize}
	\item Реального времени -- Real-time (4); 
	\item Высокий -- High (3);
	\item Выше обычного -- Above Normal (7);
	\item Обычный -- Normal (2);
	\item Ниже обычного -- Below Normal (5);
	\item Простоя -- Idle (1).
\end{itemize}

Затем для отдельных потоков назначается относительный приоритет потока, который имеет либо положительное значение либо отрицательное:

\begin{itemize}
	\item Критичный по времени -- Time-critical (15);
	\item Наивысший -- Highest (2);
	\item Выше обычного -- Above-normal (1);
	\item Обычный -- Normal (0);
	\item Ниже обычного -- Below-normal (-1);
	\item Низший -- Lowest (-2);
	\item Простоя -- Idle (–15).
\end{itemize}

Таким образом в Windows API каждый поток имеет базовый приоритет, являющийся функцией класса приоритета процесса и его относительного приоритета процесса. В таблице~\ref{tab:prior-win} представлено отображение относительный приоритет и приоритет процесса на  базовый приоритет потока.

\begin{table}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{prior}
    \caption{Отображение приоритетов ядра Windows на Windows API}
    \label{tab:prior-win}
\end{table}

У каждого потока есть 2 вида приоритетов: текущий и базовый. Текущий используется планировщиком при выборе следующего потока. В общем случае текущий приоритет равен базовому, однако он может быть повышен планировщиком. Такие повышения могут иметь следующую природу:

\begin{itemize}
	\item \textbf{Повышение вследствие событий планировщика или диспетчера:} событие установлено или отправило сигнал, мьютекс был освобожден или ликвидирован, был освобожден семафор, в очередь была вставлена запись или очередь была очищена и др. -- повышение приоритета на 2;
	\item \textbf{Повышения приоритета, связанные с завершением ожидания:} увеличение приоритета потока, вышедшего из ожидания в состояние ready -- повышение приоритета на 1;
	\item \textbf{Повышение при ожидании ресурсов исполняющей системы:} если некоторый поток блокируется при получения ресурса системы, который уже находится в исключительном владении другого поток, то для избежания зависания приоритет владеющего потока повышается через некоторое время, после начала ожидания -- приоритет повышается до 14 (если был < 14);
	\item \textbf{Повышение приоритета потоков первого плана после ожидания:} большее повышение приоритета интерактивных процессов для улучшения их отзывчивости -- приоритет повышается на текущее значение переменной \textbf{PsPrioritySeparation};
	\item \textbf{Повышения приоритета, связанные с перезагруженностью
	центрального процессора:} раз в секунду диспетчер настройки баланса, который является частью системного потока, канирует очередь готовых потоков в поиске тех из них, которые находятся в состоянии ready около 4 секунд и повышает их приоритет -- приоритет повышается до 15 (если был < 15);
	\item \textbf{Повышение приоритета после завершения ввода-вывода:} Windows дает временное повышение приоритета при завершении определенных операций ввода-вывода, при этом потоки, ожидавшие ввода-вывода, имеют	больше шансов сразу же запуститься и обработать то, чего они ожидали. Рекомендованные значения для данных повышений представлены на рисунке~\ref{fig:inout}, хотя действительные значения повышения определяются драйвером соответствующего устройства (как видно из рисунка аудио устройство имеет более высокий приоритет из-за того, что слух человека чувствительней к задержкам, по сравнению со зрением).
	\begin{table}[H]
		\centering
		\includegraphics[width=0.9\textwidth]{inout}
		\caption{Рекомендуемые значения повышения приоритета}
		\label{fig:inout}
	\end{table}
\end{itemize}

Большинство описанных выше повышений приоритетов перестают действовать после завершения кванта или нескольких, выделенных процессу. На рисунке~\ref{fig:priorgraph} представлен пример повышения и понижения приоритетов.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{priorgraph}
	\caption{Повышение и снижение приоритета}
	\label{fig:priorgraph}
\end{figure}

Для различных мультимедийных приложений, вроде воспроизведение видео/аудио требуются минимальные задержки, которые стандартные средства планировщика реализовать не могут, для клиентских версий была разработана служба MMCSS, чьей целью было гарантировать проигрывание мультимедийного контента приложений, зарегистрированных с этой службой, без каких-либо сбоев.

В действительности эта служба не повышает приоритет, как это делает планировщик, а меняет базовый приоритет процессов и потоков на время её работы. Важным свойством службы являются категории планирования, которые делят зарегистрированные процессы по приоритетам (представлены в таблице~\ref{fig:mmcss}).

\begin{table}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{mmcss}
	\caption{Категории планирования}
	\label{fig:mmcss}
\end{table}

Механизм, положенный в основу MMCSS, повышает приоритет потоков внутри зарегистрированного процесса до уровня, соответствующего их категории планирования и относительного приоритета внутри этой категории на
гарантированный срок. Затем он снижает категорию этих потоков до Exhausted, чтобы другие, не относящиеся к мультимедийным приложениям потоки, также получили шанс на выполнение. По умолчанию мультимедийные потоки получают 80\% процессорного времени. При этом сама служба MMCSS выполняется с приоритетом 27, так как ей нужно вытеснить любые управляемые ей потоки.

\textbf{IRQL}

Контроллеры прерываний сами устанавливают приоритетность своих прерываний, однако Windows определяет свою схему приоритетности, называемую IRQL, которая представлена на рисунке~\ref{fig:IRQL}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{IRQL}
	\caption{Сопоставление приоритетов потоков с IRQL-уровнями на системе x86}
	\label{fig:IRQL}
\end{figure}

Потоки обычно запускаются на уровне IRQL 0 или на уровне IRQL 1 (APC-уровень). Код пользовательского режима всегда запускается на пассивном уровне. Поэтому никакие потоки пользовательского уровня независимо от их приоритета не могут даже заблокировать аппаратные прерывания.

Потоки, запущенные в режиме ядра, несмотря на изначальное планирование на пассивном уровне или уровне APC, могут поднять IRQL на более высокие уровни, например, при выполнении системного вызова, который может включать в себя диспетчеризацию потока, диспетчеризацию памяти или ввод-вывод. Если поток поднимает IRQL на уровень dispatch или еще выше, на его процессоре не будет больше происходить ничего, относящегося к планированию потоков, пока уровень IRQL не будет опущен ниже уровня dispatch, так как прерывания обрабатываются в порядке из приоритетности. Поток выполняется на dispatch-уровне и выше, блокирует активность планировщика потоков и мешает контекстному переключению на своем процессоре.



\clearpage

\ssr{Выводы}

Так как семейства операционных систем Windows и Unix являются системами разделения времени с динамическими приоритетами пользовательских процессов и вытеснением, то функции их обработчиков системного таймера схожи. Основные из них:

\begin{itemize}
    \item Декремент кванта, по окончанию которого инициализируется диспетчеризация, которая передаёт квант другому процессу;
    \item Инкремент счётчиков времени;
    \item Инициализация работы планировщика;
    \item Декремент счётчиков отложенных вызовов.
\end{itemize}

В обоих семействах операционных систем используются динамические приоритеты, которые решают проблему бесконечного откладывания процессов и обеспечивают адаптивное распределение процессорного времени.

В UNIX приоритет пользовательского процесса (процесса в режиме задач) может динамически пересчитываться, в зависимости от трёх факторов. Приоритеты ядра — фиксированные величины.
В Windows при создании процесса ему назначается базовый приоритет, а потоку — относительный приоритет относительно этого базового. Приоритет потока может быть динамически пересчитан, при этом пересчёт осуществляется на различных основаниях, включая время простоя и приоритет сна.
